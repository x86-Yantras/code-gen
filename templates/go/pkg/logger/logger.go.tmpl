package logger

import (
	"context"
	"os"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type Fields map[string]interface{}

// Logger struct that complies to the logger interface
type Logger struct {
	AppName string
	zerolog.Logger
}

// LoggerConfig is used to pass config when initializing logger
type LoggerConfig struct {
	AppName string
	Debug   bool
}

// NewLogger returns an instance of logger
func NewLogger(config *LoggerConfig) *Logger {
	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
	lgr := zerolog.New(os.Stdout).With().Timestamp().Caller().Logger()

	return &Logger{
		AppName: config.AppName,
		Logger:  lgr,
	}
}

// Info wraps zerolog.Info()
func (l *Logger) Info(ctx context.Context, msg string, args ...Fields) {
	message := map[string]interface{}{
		"app":    l.AppName,
		"detail": args,
	}
	log.Info().Fields(message).Msg(msg)
}

// Debug wraps zerolog.Debug()
func (l *Logger) Debug(ctx context.Context, msg string, args ...Fields) {
	message := map[string]interface{}{
		"app":    l.AppName,
		"detail": args,
	}
	log.Debug().Fields(message).Msg(msg)
}

// Error wraps zerolog.Error()
func (l *Logger) Error(ctx context.Context, err error, args ...Fields) {
	message := map[string]interface{}{
		"app":    l.AppName,
		"detail": args,
	}
	log.Error().Fields(message).Err(err)
}

// Fatal wraps zerolog.Fatal()
func (l *Logger) Fatal(ctx context.Context, err error, args ...Fields) {
	message := map[string]interface{}{
		"app":    l.AppName,
		"detail": args,
	}
	log.Fatal().Fields(message).Msg(err.Error())
}
